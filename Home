{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import torch"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Exercise 1\n",
    "\n",
    "# 1. A tensor of only ones with shape (5,2)\n",
    "ones_tensor = torch.ones(5, 2)\n",
    "\n",
    "# 2. The identity matrix with shape (3,3)\n",
    "identity_matrix = torch.eye(3)\n",
    "\n",
    "# 3. A tensor only consisting of random numbers drawn from the normal distribution with shape (2,4,3)\n",
    "random_tensor = torch.randn(2, 4, 3)\n",
    "\n",
    "# 4. A tensor full of fours with shape (4,5)\n",
    "fours_tensor = 4 * torch.ones(4, 5)\n",
    "\n",
    "# 5. A tensor that has the same shape as the tensor in 3. that only consists of zeros\n",
    "zeros_like_random = torch.zeros_like(random_tensor)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Exercise 2\n",
    "\n",
    "# Given random_tensor from Exercise 1\n",
    "\n",
    "# 1. Extract the first matrix.\n",
    "first_matrix = random_tensor[0]\n",
    "\n",
    "# 2. Extract the third row of the second matrix.\n",
    "third_row_second_matrix = random_tensor[1, 2]\n",
    "\n",
    "# 3. Extract the third column of the first matrix.\n",
    "third_column_first_matrix = random_tensor[0, :, 2]\n",
    "\n",
    "# 4. Extract the item in the fourth row of the first column in the second matrix.\n",
    "item_fourth_row_first_col_second_matrix = random_tensor[1, 3, 0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Exercise 3\n",
    "\n",
    "# Given random_tensor from Exercise 1\n",
    "\n",
    "# 1. Reshape the random tensor into a 8x3 matrix.\n",
    "reshaped_random_8x3 = random_tensor.view(8, 3)\n",
    "\n",
    "# 2. Reshape the random tensor into a 2x2x2x3 tensor.\n",
    "reshaped_random_2x2x2x3 = random_tensor.view(2, 2, 2, 3)\n",
    "\n",
    "# 3. Create a tensor from the following data:\n",
    "data_tensor = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])\n",
    "\n",
    "# 4. Transpose this tensor.\n",
    "transposed_tensor = data_tensor.t()\n",
    "\n",
    "# 5. Reshape the transposed tensor to a vector with 12 elements.\n",
    "reshaped_transposed_tensor = transposed_tensor.view(12)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Exercise 4\n",
    "\n",
    "# Given data_tensor from Exercise 3\n",
    "\n",
    "# 1. Take the matrix from above and concatenate it\n",
    "concatenated_tensor = torch.cat((data_tensor, data_tensor), dim=1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Exercise 5\n",
    "\n",
    "# Given concatenated_tensor from Exercise 4\n",
    "\n",
    "# 1. Create and add the vector\n",
    "vector = torch.tensor([[1], [1], [1], [1]])\n",
    "matrix_plus_vector = torch.cat((concatenated_tensor, vector), dim=1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Exercise 6\n",
    "\n",
    "# Given data_tensor from Exercise 3\n",
    "# Given vector from Exercise 3\n",
    "\n",
    "# Create the following matrix\n",
    "matrix = data_tensor\n",
    "\n",
    "# Multiply it with the vector\n",
    "result_mm = torch.mm(matrix, vector)\n",
    "result_mv = torch.mv(matrix, vector)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Exercise 7\n",
    "\n",
    "# Create two random tensors with the shape (2, 3, 2)\n",
    "tensor1 = torch.randn(2, 3, 2)\n",
    "tensor2 = torch.randn(2, 3, 2)\n",
    "\n",
    "# Perform a batch matrix-matrix product using torch.bmm\n",
    "result1 = torch.bmm(tensor1.permute(0, 2, 1), tensor2)\n",
    "result2 = torch.bmm(tensor1, tensor2.permute(0, 2, 1))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Exercise 8\n",
    "\n",
    "# Create an embedding layer using nn.Embedding\n",
    "embedding_layer = nn.Embedding(5, 10)\n",
    "\n",
    "# Try to retrieve embeddings for inp_seq\n",
    "# Change inp_seq to integer values\n",
    "inp_seq = torch.tensor([[0, 1, 2], [2, 3, 4]])\n",
    "embeddings = embedding_layer(inp_seq)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.11"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
